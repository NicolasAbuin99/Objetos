spring.application.name=poo-clase-29-bd

# configuración de la conexión a la BD
spring.datasource.url= jdbc:mysql://127.0.0.1:3306/colegio

# el URL (Universe Resource Locator) para JDBC es una cadena de texto
# que le indica al driver JDBC dónde se encuentra la base de datos y
# cómo conectarse a ella

spring.datasource.username= root

spring.datasource.password=

# en el contexto de estas clases de pruebas, ponemos la contraseña acá mismo
# pero a nivel laboral o profesional, no es una buena práctica.
# se manejan distintas técnicas y herramientas para ocultar ese dato sensible.

# Datasource es una interfaz de Java que actúa como una fábrica de conexiones a bases de datos.
# En lugar de utilizar directamente el DriverManager.getConnection, obtenemos conexiones mediante
# dataSource.getConnection()
# Esto permite separar la configuración (URL, usuario, contraseña, pool, etc.) de la lógica de la
# aplicación. Es el estándar para acceder a conexiones en aplicaciones modernas. Es obligatoria si
# se quieren utilizar pooles de conexiones, transacciones administradas o entornos de servidor.
# Reemplaza el uso directo de DriverManager porque ofrece:
# Pooling de conexiones (reutilizar en lugar de crear cada vez). Abrir y cerrar una conexión a la
# base de datos es una operación costosa en términos de rendimiento.
# Cuando la aplicación "cierra" la conexión, esta no se cierra realmente, sino que se devuelve al
# pool para su reutilización por otra parte de la aplicación.
# Esto mejora drásticamente el rendimiento y la escalabilidad de la aplicación.
# Configuración externa (URL, credenciales, timeouts). Encapsula y abstrae la información de la
# conexión.

# HikariCP es el gestor de conexiones más rápido y eficiente que existe.
# Es una implementación ligera y de alto rendimiento de pool de conexiones JDBC.

# forzar que Spring utilice HikariCP como implementación de DataSource
spring.dataSource.type= com.zaxxer.hikari.HikariDataSource
# type indica la clase concreta de DataSource que Spring debe instanciar (Hikari)

# tamaño máximo de conexiones abiertas simultáneamente
spring.dataSource.hikari.maximun-pool-size=8
# maximum-pool-size indica cuántas conexiones en total tendrá el pool

# número mínimo de conexiones inactivas que Hikari mantendrá
spring.dataSource.hikari.minimun.idle=2
# minimum-idle indica cuántas conexiones listas para entregar tendrá, aunque no se usen

# tiempo máximo que espera un hilo para una conexión disponible (ms)
spring.dataSource.hikari.connection-timeout=30000
# conection-timeout indica que si no hay ninguna conexión libre dentro de los 30 segundos, se
# lanza una excepción.

# tiempo que una conexión puede permanecer inactiva antes de cerrarse (ms)
spring.dataSource.hikari.idle-timeout=300000
# idle-timeout cierra las conexiones no utilizadas tras 3 minutos para liberar recursos en la BD


# inicialización automática de scripts
# always -> siempre corre los scripts
# embedded -> solo para bases embebidas (H2, Derby)
# never -> no corre los scripts automáticamente, se tiene que hacer manual

# anteriormente se declaraba así, pero actualmente está deprecado desde la versión 2.5 de Spring Boot
# spring.datasource.initialization-mode=always
# de esta forma se crea actualmente
spring.sql.init.mode=always 

# Script DDL (crea tablas) en classpath:sql/schema.sql
# spring.datasource.schema=classpath:sql/schema_DDL.sql
spring.sql.init.schema-locations=classpath:sql/schema_DDL.sql

# Script DML (datos de ejemplo) en classpath:sql/data.sql
# spring.datasource.data=classpath:sql/data_DML.sql
spring.sql.init.data-locations=classpath:sql/data_DML.sql

# schema y data: rutas para los archivos que queremos que Spring ejecute, en ese orden, 
# antes de levantar la app.
# para entornos en donde las bases son muy grandes, no es buena práctica eliminar todo y 
# volver a crear, se utilizan otras herramientas para eso.



